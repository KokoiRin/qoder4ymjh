# 技术架构详解

<cite>
**本文档引用的文件**
- [MainWindow.h](file://include/ui/MainWindow.h)
- [MainWindow.cpp](file://src/ui/MainWindow.cpp)
- [WindowManager.h](file://include/core/WindowManager.h)
- [WindowManager.cpp](file://src/core/WindowManager.cpp)
- [ColorPicker.h](file://include/core/ColorPicker.h)
- [ColorPicker.cpp](file://src/core/ColorPicker.cpp)
- [ClickSimulator.h](file://include/core/ClickSimulator.h)
- [ClickSimulator.cpp](file://src/core/ClickSimulator.cpp)
</cite>

## 目录
1. [项目结构概览](#项目结构概览)
2. [MVC分层架构设计](#mvc分层架构设计)
3. [核心模块职责分析](#核心模块职责分析)
4. [组件交互与数据流](#组件交互与数据流)
5. [设计模式应用解析](#设计模式应用解析)
6. [信号槽通信机制](#信号槽通信机制)
7. [系统优势与可扩展性](#系统优势与可扩展性)

## 项目结构概览

本项目采用清晰的分层目录结构，将UI界面与核心业务逻辑分离。`include`目录下分为`ui`和`core`两个子模块，分别存放视图层和模型层头文件；`src`目录对应实现文件。这种组织方式体现了高内聚低耦合的设计原则。

```mermaid
graph TD
A[项目根目录] --> B[cmake-build-debug]
A --> C[include]
A --> D[src]
A --> E[CMakeLists.txt]
C --> F[ui]
C --> G[core]
F --> H[MainWindow.h]
G --> I[WindowManager.h]
G --> J[ColorPicker.h]
G --> K[ClickSimulator.h]
D --> L[ui]
D --> M[core]
L --> N[MainWindow.cpp]
M --> O[WindowManager.cpp]
M --> P[ColorPicker.cpp]
M --> Q[ClickSimulator.cpp]
```

**图示来源**
- [MainWindow.h](file://include/ui/MainWindow.h)
- [WindowManager.h](file://include/core/WindowManager.h)
- [ColorPicker.h](file://include/core/ColorPicker.h)
- [ClickSimulator.h](file://include/core/ClickSimulator.h)

**本节来源**
- [include/ui/MainWindow.h](file://include/ui/MainWindow.h)
- [include/core/WindowManager.h](file://include/core/WindowManager.h)
- [include/core/ColorPicker.h](file://include/core/ColorPicker.h)
- [include/core/ClickSimulator.h](file://include/core/ClickSimulator.h)

## MVC分层架构设计

系统采用类MVC（Model-View-Controller）架构模式，实现了关注点分离：

- **视图层（View）**：由`MainWindow`类及其包含的UI控件构成，负责用户界面展示与输入捕获。
- **控制层（Controller）**：体现在`MainWindow`中的各类槽函数（slots），响应UI事件并协调模型层操作。
- **模型层（Model）**：由`WindowManager`、`ColorPicker`和`ClickSimulator`三个核心模块承担，负责具体的数据处理与系统交互。

```mermaid
classDiagram
class MainWindow {
+setupUI()
+connectSignals()
-onButtonClicked()
-onRefreshWindows()
-onBindWindow()
-onStartColorPicker()
-onSimulateClick()
}
class WindowManager {
+refreshWindowList()
+bindWindow()
+bringWindowToFront()
}
class ColorPicker {
+startPicking()
+stopPicking()
+getColorAt()
}
class ClickSimulator {
+click()
+setTargetWindow()
+mouseDown()
+mouseUp()
}
MainWindow --> WindowManager : "组合"
MainWindow --> ColorPicker : "组合"
MainWindow --> ClickSimulator : "组合"
MainWindow ..> WindowManager : "通过信号槽通信"
MainWindow ..> ColorPicker : "通过信号槽通信"
MainWindow ..> ClickSimulator : "通过信号槽通信"
```

**图示来源**
- [MainWindow.h](file://include/ui/MainWindow.h#L23-L106)
- [WindowManager.h](file://include/core/WindowManager.h#L22-L61)
- [ColorPicker.h](file://include/core/ColorPicker.h#L12-L56)
- [ClickSimulator.h](file://include/core/ClickSimulator.h#L27-L96)

**本节来源**
- [MainWindow.h](file://include/ui/MainWindow.h#L23-L106)
- [WindowManager.h](file://include/core/WindowManager.h#L22-L61)
- [ColorPicker.h](file://include/core/ColorPicker.h#L12-L56)
- [ClickSimulator.h](file://include/core/ClickSimulator.h#L27-L96)

## 核心模块职责分析

### WindowManager 模块
作为窗口管理模型，负责枚举系统窗口、维护窗口列表、绑定目标窗口及执行窗口操作（如置顶）。通过Windows API实现底层功能，并提供安全的C++接口。

**本节来源**
- [WindowManager.h](file://include/core/WindowManager.h#L22-L61)
- [WindowManager.cpp](file://src/core/WindowManager.cpp#L10-L15)

### ColorPicker 模块
实现颜色拾取功能，支持实时跟踪鼠标位置的颜色变化，并可通过点击获取精确颜色值。使用`QTimer`定期更新，确保性能与用户体验的平衡。

**本节来源**
- [ColorPicker.h](file://include/core/ColorPicker.h#L12-L56)
- [ColorPicker.cpp](file://src/core/ColorPicker.cpp#L17-L24)

### ClickSimulator 模块
模拟鼠标点击行为，支持多种坐标系（屏幕、窗口、客户区）、不同按键类型及单双击操作。通过Windows消息机制发送`WM_LBUTTONDOWN`等消息实现真实点击效果。

**本节来源**
- [ClickSimulator.h](file://include/core/ClickSimulator.h#L27-L96)
- [ClickSimulator.cpp](file://src/core/ClickSimulator.cpp#L36-L76)

## 组件交互与数据流

系统遵循清晰的数据流动路径：用户操作触发UI事件 → 控制层槽函数响应 → 调用模型层方法处理 → 调用Windows API执行系统操作 → 结果以信号形式返回 → UI根据信号刷新状态。

```mermaid
flowchart LR
A[用户操作] --> B[UI事件]
B --> C[槽函数]
C --> D[核心模块]
D --> E[Windows API调用]
E --> F[系统响应]
F --> G[结果信号]
G --> H[UI刷新]
```

**图示来源**
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L276-L291)
- [ClickSimulator.cpp](file://src/core/ClickSimulator.cpp#L36-L76)

**本节来源**
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L276-L291)
- [ClickSimulator.cpp](file://src/core/ClickSimulator.cpp#L36-L76)

## 设计模式应用解析

### 观察者模式
Qt的信号槽机制是观察者模式的典型应用。例如`ColorPicker`发出`colorChanged`信号，`MainWindow`作为观察者连接该信号并更新UI显示。

```mermaid
sequenceDiagram
participant CP as ColorPicker
participant MW as MainWindow
CP->>CP : startPicking()
loop 定时器循环
CP->>CP : updateColor()
CP->>MW : emit colorChanged(color, pos)
MW->>MW : onColorChanged(color, pos)
MW->>MW : updateColorDisplay()
end
```

**图示来源**
- [ColorPicker.h](file://include/core/ColorPicker.h#L50-L52)
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L178-L211)
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L293-L296)

### 组合模式
`MainWindow`通过成员变量聚合三个核心模块实例，形成整体-部分关系，便于统一管理和生命周期控制。

**本节来源**
- [MainWindow.h](file://include/ui/MainWindow.h#L50-L52)

### 状态模式
各功能模块内部维护自身状态，如`ColorPicker`的`isPickingActive`标志位控制取色器的启动/停止状态，体现状态模式思想。

**本节来源**
- [ColorPicker.h](file://include/core/ColorPicker.h#L43-L44)
- [ColorPicker.cpp](file://src/core/ColorPicker.cpp#L17-L24)

## 信号槽通信机制

系统通过Qt信号槽实现松耦合通信。`MainWindow`在`connectSignals()`中建立完整连接网络：

- UI控件 → `MainWindow`槽函数
- 核心模块 → `MainWindow`槽函数
- 设置控件 → 核心模块方法

```mermaid
graph LR
A[QPushButton] --> |clicked| B[MainWindow::onStartColorPicker]
C[ColorPicker] --> |colorChanged| D[MainWindow::onColorChanged]
E[ClickSimulator] --> |clickExecuted| F[MainWindow::onClickExecuted]
G[QSpinBox] --> |valueChanged| H[ColorPicker::setUpdateInterval]
```

**图示来源**
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L178-L211)

**本节来源**
- [MainWindow.cpp](file://src/ui/MainWindow.cpp#L178-L211)

## 系统优势与可扩展性

### 高内聚低耦合
各模块职责单一，依赖关系清晰，修改一个模块不影响其他部分。

### 易于扩展
新增功能（如键盘模拟器）只需：
1. 创建新模型类继承`QObject`
2. 定义必要信号与槽
3. 在`MainWindow`中添加实例并连接信号

### 便于测试
核心模块不依赖UI，可独立进行单元测试，提高代码质量与可靠性。

**本节来源**
- [MainWindow.h](file://include/ui/MainWindow.h#L23-L106)
- [ClickSimulator.h](file://include/core/ClickSimulator.h#L27-L96)